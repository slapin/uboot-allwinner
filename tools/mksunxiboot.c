/*
 * (C) Copyright 2007-2011
 * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
 * Tom Cubie <tangliang@allwinnertech.com>
 *
 * a simple tool to generate bootable image for sunxi platform.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>

typedef int s32;
typedef unsigned char u8;
typedef unsigned int u32;

/* boot head definition from sun4i boot code */
typedef struct boot_file_head {
	u32 jump_instruction;	/* one intruction jumping to real code */
	u8 magic[8];		/* ="eGON.BT0" or "eGON.BT1", not C-style str */
	u32 check_sum;		/* generated by PC */
	u32 length;		/* generated by PC */
#if 0
	/* We use a simplified header, only filling in what is needed by the boot ROM.
	 * To be compatible with Allwinner tools the larger header below should be used,
	 * followed by a custom header if desired. */
	u8 pad[12];		/* align to 32 bytes */
#else
	u32 pub_head_size;	/* the size of boot_file_head_t */
	u8 pub_head_vsn[4];	/* the version of boot_file_head_t */
	u8 file_head_vsn[4];	/* the version of boot0_file_head_t or
				   boot1_file_head_t */
	u8 Boot_vsn[4];		/* Boot version */
	u8 eGON_vsn[4];		/* eGON version */
	u8 platform[8];		/* platform information */
#endif
} boot_file_head_t;

typedef struct _boot_dram_para_t {
    u32 dram_baseaddr;
    u32 dram_clk;
    u32 dram_type;
    u32 dram_rank_num;
    u32 dram_chip_density;
    u32 dram_io_width;
    u32 dram_bus_width;
    u32 dram_cas;
    u32 dram_zq;
    u32 dram_odt_en;
    u32 dram_size;
    u32 dram_tpr0;
    u32 dram_tpr1;
    u32 dram_tpr2;
    u32 dram_tpr3;
    u32 dram_tpr4;
    u32 dram_tpr5;
    u32 dram_emr1;
    u32 dram_emr2;
    u32 dram_emr3;
} boot_dram_para_t;

typedef struct _normal_gpio_cfg {
    u8 port;
    u8 port_num;
    u8 mul_sel;
    u8 pull;
    u8 drv_level;
    u8 data;
    u8 reserved[2];
} normal_gpio_cfg;

typedef struct _boot0_private_head_t {
    u32 prvt_head_size;
    char prvt_head_vsn[4];
    boot_dram_para_t dram_para;
    s32 uart_port;
    normal_gpio_cfg uart_ctrl[2];
    s32 enable_jtag;
    normal_gpio_cfg jtag_gpio[5];
    normal_gpio_cfg storage_gpio[32];
    u8 storage_data[256];
} boot0_private_head_t;

typedef struct _boot0_file_head_t {
    boot_file_head_t boot_head;
    boot0_private_head_t prvt_head;
	char pad[8];
} boot0_file_head_t;

#define CONFIG_SUNXI_NAND_SPL

#define BOOT0_MAGIC                     "eGON.BT0"
#define STAMP_VALUE                     0x5F0A6C39
#ifdef CONFIG_SUNXI_NAND_SPL
#define BOOT0_ALIGN_SIZE                0x2000
#else
#define BOOT0_ALIGN_SIZE                0x0400
#endif
#define BOOT_PUB_HEAD_VERSION           "1100"
#define BOOT0_FILE_HEAD_VERSION         "1230"
#define BOOT0_VERSION                   "1230"
#define EGON_VERSION                    "1100"
#define BOOT0_PRVT_HEAD_VERSION         "1230"

const boot0_file_head_t boot0_head = {
	{
		(0xEA000000 | (((sizeof(boot0_file_head_t) + sizeof(int) - 1) / sizeof(int) - 2) & 0x00FFFFFF)),
		BOOT0_MAGIC,
		STAMP_VALUE,
		BOOT0_ALIGN_SIZE,
		sizeof(boot_file_head_t),
		BOOT_PUB_HEAD_VERSION,
		BOOT0_FILE_HEAD_VERSION,
		BOOT0_VERSION,
		EGON_VERSION,
		{ 0, '1', '.', '5', '.', '0', 0, 0 },
	},

	{
		sizeof( boot0_private_head_t ),
		BOOT0_PRVT_HEAD_VERSION,
		{ 
			0x40000000,
			360,
			3,
			1,
			2048,
			16,
			32,
			6,
			0x7b,
			0,
			512,
			0x30926692,
			0x1090,
			0x1a0c8,
			0x0,
			0x0,
			0x0,
			0x0,
			0x0,
			0x0
		},
		0,
		{
			{ 2, 22, 2, 1, 1, 0, 0, 0},
			{ 2, 23, 2, 1, 1, 0, 0, 0}
		},
		0,
		{ 0 },
		{ 0 },
		{ 0 }
	},

	{ 0 }
};

#define ALIGN(x,a)      __ALIGN_MASK((x),(typeof(x))(a)-1)
#define __ALIGN_MASK(x,mask)    (((x)+(mask))&~(mask))

#define SUN4I_SRAM_SIZE (24 * 1024)
u8 buffer[SUN4I_SRAM_SIZE];

/* check sum functon from sun4i boot code */
void gen_check_sum(void)
{
	boot_file_head_t *head_p;
	u32 length;
	u32 *buf;
	u32 loop;
	u32 i;
	u32 sum;

	head_p = (boot_file_head_t *)buffer;
	length = head_p->length;
	buf = (u32 *)buffer;
	loop = length >> 2;

	/* calculate the sum */
	for (i = 0, sum = 0; i < loop; i++)
		sum += buf[i];

	/* write back check sum */
	head_p->check_sum = sum;
}

int main(int argc, char *argv[])
{
	int fd_in, fd_out;
	unsigned file_size, aligned_size;
	int count;
	boot_file_head_t *boot_file_head;

	if (argc < 2) {
		printf
			("\tThis program makes an input bin file to sun4i bootable image.\n"
			 "\tUsage: %s input_file out_putfile\n", argv[0]);
		goto out0;
	}

	fd_in = open(argv[1], O_RDONLY);
	if (fd_in < 0) {
		perror("Open input file:");
		goto out0;
	}

	fd_out = open(argv[2], O_WRONLY | O_CREAT, 0666);
	if (fd_out < 0) {
		perror("Open output file:");
		goto out1;
	}

	/* get input file size */
	file_size = lseek(fd_in, 0, SEEK_END);
	printf("File size: 0x%x \n", file_size);

	if (file_size + sizeof(boot0_file_head_t) > SUN4I_SRAM_SIZE) {
		perror("input file size too big\n");
		goto out2;
	}

	/* set padding */
	memset(buffer, 0xff, SUN4I_SRAM_SIZE);

	/* copy head */
	memcpy(buffer, &boot0_head, sizeof(boot0_file_head_t));

	/* read file to buffer to calculate checksum */
	lseek(fd_in, 0, SEEK_SET);
	count = read(fd_in, buffer + sizeof(boot0_file_head_t), file_size);
	printf("Read 0x%x bytes at offset %x\n", count, sizeof(boot0_file_head_t));

	/* boot head is at begginning */
	boot_file_head = (boot_file_head_t *)buffer;
	printf("Image should be %x aligned\n", boot_file_head->length);
	aligned_size = ALIGN(file_size + sizeof(boot0_file_head_t), boot_file_head->length);
	if (aligned_size > SUN4I_SRAM_SIZE) {
		perror("aligned size too big\n");
		goto out2;
	}

	boot_file_head->length = aligned_size;
	gen_check_sum();

	count = write(fd_out, buffer, aligned_size);
	printf("Write 0x%x bytes\n", count);

	close(fd_in);
	close(fd_out);

	return EXIT_SUCCESS;

out2:
	close(fd_out);
out1:
	close(fd_in);
out0:
	return EXIT_FAILURE;
}
